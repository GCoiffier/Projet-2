open Formula

let max_var f =
  (* count the number of variables of f. Variables should be 1 to n. *)
  let rec nb_var_aux m f = match f with
     Const(k) -> m
    |Var(x) -> if x>m then x else m
    |OR(f1,f2) -> max (nb_var_aux m f1) (nb_var_aux m f2)
    |AND(f1,f2) -> max (nb_var_aux m f1) (nb_var_aux m f2)
    |XOR(f1,f2) -> max (nb_var_aux m f1) (nb_var_aux m f2)
    |NOT(f)-> nb_var_aux m f
    |IMPLIES(f1,f2) -> max (nb_var_aux m f1) (nb_var_aux m f2)
    |EQUIV(f1,f2) -> max (nb_var_aux m f1) (nb_var_aux m f2)
  in nb_var_aux 0 f;;
  
let nb_clause expr = 
	let rec aux expr = match expr with
	|AND(e1,e2) -> 1 + aux e1 + aux e2
	|_ -> 0 in
   1 + aux expr

<<<<<<< HEAD
let output_int f q =
	output_string f ( string_of_int( q ) )

let print_for_minisat expr =
	let f = open_out "_build/input.cnf" in
	output_string f "p cnf ";
	output_int f (max_var expr);
	output_string f " ";
	output_int f (nb_clause expr);
	output_string f "\n";
	
	let rec print_clause cl = match cl with
		|OR(e1, e2) -> print_clause e1; print_clause e2
		|Var(q) -> output_int f q; output_string f " "
		|NOT(Var(q)) -> output_int f (-q); output_string f "  "
=======
let print_minisat expr =
	print_string "p cnf ";
	print_int (max_var expr);
	print_int (nb_Clause expr);
	print_string "\n";
	
	let rec print_clause cl = match cl with
		|OR(e1, e2) -> print_clause e1; print_clause e2
		|Var(q) -> print_int q; print_string " "
		|NOT(Var(q)) -> print_int (-q); print_string "  "
>>>>>>> 4182964187907ac46e6c166dc39e400c68e978a2
		|_ -> failwith "Not a cnf expression" in
	
	let rec print_cnf expr = match expr with
		|AND(e1, e2) -> print_cnf e1; print_cnf e2
<<<<<<< HEAD
		|_ -> print_clause expr; output_string f "0\n" in
	
	print_cnf expr;
	close_out f
	
let minisat expr =
	print_for_minisat expr;
	Sys.command "minisat _build/input.cnf output.txt";
	
	

	

=======
		|_ -> print_clause expr; print_string "0\n" in
	
	print_cnf expr 
	
>>>>>>> 4182964187907ac46e6c166dc39e400c68e978a2
